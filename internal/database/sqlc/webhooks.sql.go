// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countWebhookEventsByBucketID = `-- name: CountWebhookEventsByBucketID :one
SELECT COUNT(*) AS count FROM webhook_events WHERE bucket_id = ?
`

func (q *Queries) CountWebhookEventsByBucketID(ctx context.Context, bucketID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWebhookEventsByBucketID, bucketID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWebhookEvent = `-- name: CreateWebhookEvent :one
INSERT INTO webhook_events (id, webhook_url_id, bucket_id, resource_id, event_type, status, payload, max_attempts)
VALUES (?, ?, ?, ?, ?, 'pending', ?, ?)
RETURNING id, webhook_url_id, bucket_id, resource_id, event_type, status, payload,
          response_code, response_body, attempts, max_attempts, next_retry_at,
          last_attempt_at, created_at, completed_at
`

type CreateWebhookEventParams struct {
	ID           string `json:"id"`
	WebhookUrlID string `json:"webhook_url_id"`
	BucketID     string `json:"bucket_id"`
	ResourceID   string `json:"resource_id"`
	EventType    string `json:"event_type"`
	Payload      string `json:"payload"`
	MaxAttempts  int64  `json:"max_attempts"`
}

func (q *Queries) CreateWebhookEvent(ctx context.Context, arg CreateWebhookEventParams) (WebhookEvent, error) {
	row := q.db.QueryRowContext(ctx, createWebhookEvent,
		arg.ID,
		arg.WebhookUrlID,
		arg.BucketID,
		arg.ResourceID,
		arg.EventType,
		arg.Payload,
		arg.MaxAttempts,
	)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.WebhookUrlID,
		&i.BucketID,
		&i.ResourceID,
		&i.EventType,
		&i.Status,
		&i.Payload,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.Attempts,
		&i.MaxAttempts,
		&i.NextRetryAt,
		&i.LastAttemptAt,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createWebhookHeader = `-- name: CreateWebhookHeader :one
INSERT INTO webhook_headers (id, webhook_url_id, header_name, header_value)
VALUES (?, ?, ?, ?)
RETURNING id, webhook_url_id, header_name, header_value, created_at
`

type CreateWebhookHeaderParams struct {
	ID           string `json:"id"`
	WebhookUrlID string `json:"webhook_url_id"`
	HeaderName   string `json:"header_name"`
	HeaderValue  string `json:"header_value"`
}

func (q *Queries) CreateWebhookHeader(ctx context.Context, arg CreateWebhookHeaderParams) (WebhookHeader, error) {
	row := q.db.QueryRowContext(ctx, createWebhookHeader,
		arg.ID,
		arg.WebhookUrlID,
		arg.HeaderName,
		arg.HeaderValue,
	)
	var i WebhookHeader
	err := row.Scan(
		&i.ID,
		&i.WebhookUrlID,
		&i.HeaderName,
		&i.HeaderValue,
		&i.CreatedAt,
	)
	return i, err
}

const createWebhookURL = `-- name: CreateWebhookURL :one
INSERT INTO webhook_urls (id, bucket_id, url, event_type, is_active)
VALUES (?, ?, ?, ?, ?)
RETURNING id, bucket_id, url, event_type, is_active, created_at, updated_at
`

type CreateWebhookURLParams struct {
	ID        string `json:"id"`
	BucketID  string `json:"bucket_id"`
	Url       string `json:"url"`
	EventType string `json:"event_type"`
	IsActive  int64  `json:"is_active"`
}

func (q *Queries) CreateWebhookURL(ctx context.Context, arg CreateWebhookURLParams) (WebhookUrl, error) {
	row := q.db.QueryRowContext(ctx, createWebhookURL,
		arg.ID,
		arg.BucketID,
		arg.Url,
		arg.EventType,
		arg.IsActive,
	)
	var i WebhookUrl
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Url,
		&i.EventType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWebhookHeader = `-- name: DeleteWebhookHeader :execrows
DELETE FROM webhook_headers WHERE id = ?
`

func (q *Queries) DeleteWebhookHeader(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWebhookHeader, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteWebhookHeadersByURLID = `-- name: DeleteWebhookHeadersByURLID :execrows
DELETE FROM webhook_headers WHERE webhook_url_id = ?
`

func (q *Queries) DeleteWebhookHeadersByURLID(ctx context.Context, webhookUrlID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWebhookHeadersByURLID, webhookUrlID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteWebhookURL = `-- name: DeleteWebhookURL :execrows
DELETE FROM webhook_urls WHERE id = ?
`

func (q *Queries) DeleteWebhookURL(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWebhookURL, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getWebhookEventByID = `-- name: GetWebhookEventByID :one

SELECT id, webhook_url_id, bucket_id, resource_id, event_type, status, payload,
       response_code, response_body, attempts, max_attempts, next_retry_at,
       last_attempt_at, created_at, completed_at
FROM webhook_events WHERE id = ?
`

// Webhook Events queries
func (q *Queries) GetWebhookEventByID(ctx context.Context, id string) (WebhookEvent, error) {
	row := q.db.QueryRowContext(ctx, getWebhookEventByID, id)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.WebhookUrlID,
		&i.BucketID,
		&i.ResourceID,
		&i.EventType,
		&i.Status,
		&i.Payload,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.Attempts,
		&i.MaxAttempts,
		&i.NextRetryAt,
		&i.LastAttemptAt,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getWebhookHeaderByID = `-- name: GetWebhookHeaderByID :one

SELECT id, webhook_url_id, header_name, header_value, created_at
FROM webhook_headers WHERE id = ?
`

// Webhook Headers queries
func (q *Queries) GetWebhookHeaderByID(ctx context.Context, id string) (WebhookHeader, error) {
	row := q.db.QueryRowContext(ctx, getWebhookHeaderByID, id)
	var i WebhookHeader
	err := row.Scan(
		&i.ID,
		&i.WebhookUrlID,
		&i.HeaderName,
		&i.HeaderValue,
		&i.CreatedAt,
	)
	return i, err
}

const getWebhookURLByID = `-- name: GetWebhookURLByID :one

SELECT id, bucket_id, url, event_type, is_active, created_at, updated_at
FROM webhook_urls WHERE id = ?
`

// Webhook URLs queries
func (q *Queries) GetWebhookURLByID(ctx context.Context, id string) (WebhookUrl, error) {
	row := q.db.QueryRowContext(ctx, getWebhookURLByID, id)
	var i WebhookUrl
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Url,
		&i.EventType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveWebhookURLsByBucketAndEvent = `-- name: ListActiveWebhookURLsByBucketAndEvent :many
SELECT id, bucket_id, url, event_type, is_active, created_at, updated_at
FROM webhook_urls WHERE bucket_id = ? AND event_type = ? AND is_active = 1
`

type ListActiveWebhookURLsByBucketAndEventParams struct {
	BucketID  string `json:"bucket_id"`
	EventType string `json:"event_type"`
}

func (q *Queries) ListActiveWebhookURLsByBucketAndEvent(ctx context.Context, arg ListActiveWebhookURLsByBucketAndEventParams) ([]WebhookUrl, error) {
	rows, err := q.db.QueryContext(ctx, listActiveWebhookURLsByBucketAndEvent, arg.BucketID, arg.EventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookUrl{}
	for rows.Next() {
		var i WebhookUrl
		if err := rows.Scan(
			&i.ID,
			&i.BucketID,
			&i.Url,
			&i.EventType,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingWebhookEvents = `-- name: ListPendingWebhookEvents :many
SELECT id, webhook_url_id, bucket_id, resource_id, event_type, status, payload,
       response_code, response_body, attempts, max_attempts, next_retry_at,
       last_attempt_at, created_at, completed_at
FROM webhook_events
WHERE (status = 'pending' OR (status = 'retrying' AND next_retry_at <= CURRENT_TIMESTAMP))
AND attempts < max_attempts
ORDER BY created_at ASC LIMIT ?
`

func (q *Queries) ListPendingWebhookEvents(ctx context.Context, limit int64) ([]WebhookEvent, error) {
	rows, err := q.db.QueryContext(ctx, listPendingWebhookEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookEvent{}
	for rows.Next() {
		var i WebhookEvent
		if err := rows.Scan(
			&i.ID,
			&i.WebhookUrlID,
			&i.BucketID,
			&i.ResourceID,
			&i.EventType,
			&i.Status,
			&i.Payload,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.MaxAttempts,
			&i.NextRetryAt,
			&i.LastAttemptAt,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookEventsByBucketID = `-- name: ListWebhookEventsByBucketID :many
SELECT id, webhook_url_id, bucket_id, resource_id, event_type, status, payload,
       response_code, response_body, attempts, max_attempts, next_retry_at,
       last_attempt_at, created_at, completed_at
FROM webhook_events WHERE bucket_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListWebhookEventsByBucketIDParams struct {
	BucketID string `json:"bucket_id"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) ListWebhookEventsByBucketID(ctx context.Context, arg ListWebhookEventsByBucketIDParams) ([]WebhookEvent, error) {
	rows, err := q.db.QueryContext(ctx, listWebhookEventsByBucketID, arg.BucketID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookEvent{}
	for rows.Next() {
		var i WebhookEvent
		if err := rows.Scan(
			&i.ID,
			&i.WebhookUrlID,
			&i.BucketID,
			&i.ResourceID,
			&i.EventType,
			&i.Status,
			&i.Payload,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.MaxAttempts,
			&i.NextRetryAt,
			&i.LastAttemptAt,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookHeadersByURLID = `-- name: ListWebhookHeadersByURLID :many
SELECT id, webhook_url_id, header_name, header_value, created_at
FROM webhook_headers WHERE webhook_url_id = ? ORDER BY header_name
`

func (q *Queries) ListWebhookHeadersByURLID(ctx context.Context, webhookUrlID string) ([]WebhookHeader, error) {
	rows, err := q.db.QueryContext(ctx, listWebhookHeadersByURLID, webhookUrlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookHeader{}
	for rows.Next() {
		var i WebhookHeader
		if err := rows.Scan(
			&i.ID,
			&i.WebhookUrlID,
			&i.HeaderName,
			&i.HeaderValue,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookURLsByBucketID = `-- name: ListWebhookURLsByBucketID :many
SELECT id, bucket_id, url, event_type, is_active, created_at, updated_at
FROM webhook_urls WHERE bucket_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListWebhookURLsByBucketID(ctx context.Context, bucketID string) ([]WebhookUrl, error) {
	rows, err := q.db.QueryContext(ctx, listWebhookURLsByBucketID, bucketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookUrl{}
	for rows.Next() {
		var i WebhookUrl
		if err := rows.Scan(
			&i.ID,
			&i.BucketID,
			&i.Url,
			&i.EventType,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWebhookEventStatus = `-- name: UpdateWebhookEventStatus :exec
UPDATE webhook_events
SET status = ?, response_code = ?, response_body = ?, attempts = attempts + 1,
    last_attempt_at = CURRENT_TIMESTAMP, next_retry_at = ?, completed_at = ?
WHERE id = ?
`

type UpdateWebhookEventStatusParams struct {
	Status       string         `json:"status"`
	ResponseCode sql.NullInt64  `json:"response_code"`
	ResponseBody sql.NullString `json:"response_body"`
	NextRetryAt  sql.NullTime   `json:"next_retry_at"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateWebhookEventStatus(ctx context.Context, arg UpdateWebhookEventStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateWebhookEventStatus,
		arg.Status,
		arg.ResponseCode,
		arg.ResponseBody,
		arg.NextRetryAt,
		arg.CompletedAt,
		arg.ID,
	)
	return err
}

const updateWebhookHeader = `-- name: UpdateWebhookHeader :one
UPDATE webhook_headers SET header_value = ? WHERE id = ?
RETURNING id, webhook_url_id, header_name, header_value, created_at
`

type UpdateWebhookHeaderParams struct {
	HeaderValue string `json:"header_value"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateWebhookHeader(ctx context.Context, arg UpdateWebhookHeaderParams) (WebhookHeader, error) {
	row := q.db.QueryRowContext(ctx, updateWebhookHeader, arg.HeaderValue, arg.ID)
	var i WebhookHeader
	err := row.Scan(
		&i.ID,
		&i.WebhookUrlID,
		&i.HeaderName,
		&i.HeaderValue,
		&i.CreatedAt,
	)
	return i, err
}

const updateWebhookURL = `-- name: UpdateWebhookURL :one
UPDATE webhook_urls
SET url = ?, event_type = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, bucket_id, url, event_type, is_active, created_at, updated_at
`

type UpdateWebhookURLParams struct {
	Url       string `json:"url"`
	EventType string `json:"event_type"`
	IsActive  int64  `json:"is_active"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateWebhookURL(ctx context.Context, arg UpdateWebhookURLParams) (WebhookUrl, error) {
	row := q.db.QueryRowContext(ctx, updateWebhookURL,
		arg.Url,
		arg.EventType,
		arg.IsActive,
		arg.ID,
	)
	var i WebhookUrl
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Url,
		&i.EventType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const webhookURLExists = `-- name: WebhookURLExists :one
SELECT EXISTS(SELECT 1 FROM webhook_urls WHERE bucket_id = ? AND url = ? AND event_type = ?) AS webhook_exists
`

type WebhookURLExistsParams struct {
	BucketID  string `json:"bucket_id"`
	Url       string `json:"url"`
	EventType string `json:"event_type"`
}

func (q *Queries) WebhookURLExists(ctx context.Context, arg WebhookURLExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, webhookURLExists, arg.BucketID, arg.Url, arg.EventType)
	var webhook_exists int64
	err := row.Scan(&webhook_exists)
	return webhook_exists, err
}
