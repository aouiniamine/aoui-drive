// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resources.sql

package sqlc

import (
	"context"
)

const createResource = `-- name: CreateResource :one
INSERT INTO resources (id, bucket_id, hash, size, content_type)
VALUES (?, ?, ?, ?, ?)
RETURNING id, bucket_id, hash, size, content_type, created_at
`

type CreateResourceParams struct {
	ID          string `json:"id"`
	BucketID    string `json:"bucket_id"`
	Hash        string `json:"hash"`
	Size        int64  `json:"size"`
	ContentType string `json:"content_type"`
}

func (q *Queries) CreateResource(ctx context.Context, arg CreateResourceParams) (Resource, error) {
	row := q.db.QueryRowContext(ctx, createResource,
		arg.ID,
		arg.BucketID,
		arg.Hash,
		arg.Size,
		arg.ContentType,
	)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Hash,
		&i.Size,
		&i.ContentType,
		&i.CreatedAt,
	)
	return i, err
}

const deleteResource = `-- name: DeleteResource :execrows
DELETE FROM resources WHERE id = ?
`

func (q *Queries) DeleteResource(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteResource, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteResourceByBucketAndHash = `-- name: DeleteResourceByBucketAndHash :execrows
DELETE FROM resources WHERE bucket_id = ? AND hash = ?
`

type DeleteResourceByBucketAndHashParams struct {
	BucketID string `json:"bucket_id"`
	Hash     string `json:"hash"`
}

func (q *Queries) DeleteResourceByBucketAndHash(ctx context.Context, arg DeleteResourceByBucketAndHashParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteResourceByBucketAndHash, arg.BucketID, arg.Hash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getResourceByBucketAndHash = `-- name: GetResourceByBucketAndHash :one
SELECT id, bucket_id, hash, size, content_type, created_at
FROM resources WHERE bucket_id = ? AND hash = ?
`

type GetResourceByBucketAndHashParams struct {
	BucketID string `json:"bucket_id"`
	Hash     string `json:"hash"`
}

func (q *Queries) GetResourceByBucketAndHash(ctx context.Context, arg GetResourceByBucketAndHashParams) (Resource, error) {
	row := q.db.QueryRowContext(ctx, getResourceByBucketAndHash, arg.BucketID, arg.Hash)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Hash,
		&i.Size,
		&i.ContentType,
		&i.CreatedAt,
	)
	return i, err
}

const getResourceByID = `-- name: GetResourceByID :one
SELECT id, bucket_id, hash, size, content_type, created_at
FROM resources WHERE id = ?
`

func (q *Queries) GetResourceByID(ctx context.Context, id string) (Resource, error) {
	row := q.db.QueryRowContext(ctx, getResourceByID, id)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.BucketID,
		&i.Hash,
		&i.Size,
		&i.ContentType,
		&i.CreatedAt,
	)
	return i, err
}

const listResourcesByBucketID = `-- name: ListResourcesByBucketID :many
SELECT id, bucket_id, hash, size, content_type, created_at
FROM resources WHERE bucket_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListResourcesByBucketID(ctx context.Context, bucketID string) ([]Resource, error) {
	rows, err := q.db.QueryContext(ctx, listResourcesByBucketID, bucketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.BucketID,
			&i.Hash,
			&i.Size,
			&i.ContentType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resourceExistsByBucketAndHash = `-- name: ResourceExistsByBucketAndHash :one
SELECT EXISTS(SELECT 1 FROM resources WHERE bucket_id = ? AND hash = ?) AS resource_exists
`

type ResourceExistsByBucketAndHashParams struct {
	BucketID string `json:"bucket_id"`
	Hash     string `json:"hash"`
}

func (q *Queries) ResourceExistsByBucketAndHash(ctx context.Context, arg ResourceExistsByBucketAndHashParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, resourceExistsByBucketAndHash, arg.BucketID, arg.Hash)
	var resource_exists int64
	err := row.Scan(&resource_exists)
	return resource_exists, err
}
