// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: buckets.sql

package sqlc

import (
	"context"
)

const bucketExistsByNameAndClientID = `-- name: BucketExistsByNameAndClientID :one
SELECT EXISTS(SELECT 1 FROM buckets WHERE name = ? AND client_id = ?) AS bucket_exists
`

type BucketExistsByNameAndClientIDParams struct {
	Name     string `json:"name"`
	ClientID string `json:"client_id"`
}

func (q *Queries) BucketExistsByNameAndClientID(ctx context.Context, arg BucketExistsByNameAndClientIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, bucketExistsByNameAndClientID, arg.Name, arg.ClientID)
	var bucket_exists int64
	err := row.Scan(&bucket_exists)
	return bucket_exists, err
}

const createBucket = `-- name: CreateBucket :one
INSERT INTO buckets (id, name, client_id, is_public)
VALUES (?, ?, ?, ?)
RETURNING id, name, client_id, is_public, created_at, updated_at
`

type CreateBucketParams struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	ClientID string `json:"client_id"`
	IsPublic int64  `json:"is_public"`
}

func (q *Queries) CreateBucket(ctx context.Context, arg CreateBucketParams) (Bucket, error) {
	row := q.db.QueryRowContext(ctx, createBucket,
		arg.ID,
		arg.Name,
		arg.ClientID,
		arg.IsPublic,
	)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClientID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBucket = `-- name: DeleteBucket :execrows
DELETE FROM buckets WHERE id = ?
`

func (q *Queries) DeleteBucket(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteBucket, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getBucketByID = `-- name: GetBucketByID :one
SELECT id, name, client_id, is_public, created_at, updated_at
FROM buckets WHERE id = ?
`

func (q *Queries) GetBucketByID(ctx context.Context, id string) (Bucket, error) {
	row := q.db.QueryRowContext(ctx, getBucketByID, id)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClientID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBucketByNameAndClientID = `-- name: GetBucketByNameAndClientID :one
SELECT id, name, client_id, is_public, created_at, updated_at
FROM buckets WHERE name = ? AND client_id = ?
`

type GetBucketByNameAndClientIDParams struct {
	Name     string `json:"name"`
	ClientID string `json:"client_id"`
}

func (q *Queries) GetBucketByNameAndClientID(ctx context.Context, arg GetBucketByNameAndClientIDParams) (Bucket, error) {
	row := q.db.QueryRowContext(ctx, getBucketByNameAndClientID, arg.Name, arg.ClientID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClientID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublicBucketByName = `-- name: GetPublicBucketByName :one
SELECT id, name, client_id, is_public, created_at, updated_at
FROM buckets WHERE name = ? AND is_public = 1
`

func (q *Queries) GetPublicBucketByName(ctx context.Context, name string) (Bucket, error) {
	row := q.db.QueryRowContext(ctx, getPublicBucketByName, name)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClientID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBuckets = `-- name: ListBuckets :many
SELECT id, name, client_id, is_public, created_at, updated_at
FROM buckets ORDER BY name
`

func (q *Queries) ListBuckets(ctx context.Context) ([]Bucket, error) {
	rows, err := q.db.QueryContext(ctx, listBuckets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bucket{}
	for rows.Next() {
		var i Bucket
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ClientID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBucketsByClientID = `-- name: ListBucketsByClientID :many
SELECT id, name, client_id, is_public, created_at, updated_at
FROM buckets WHERE client_id = ? ORDER BY name
`

func (q *Queries) ListBucketsByClientID(ctx context.Context, clientID string) ([]Bucket, error) {
	rows, err := q.db.QueryContext(ctx, listBucketsByClientID, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bucket{}
	for rows.Next() {
		var i Bucket
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ClientID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
